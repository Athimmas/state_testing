
    Report from: Interprocedural optimizations [ipo]

  WHOLE PROGRAM (SAFE) [EITHER METHOD]: false
  WHOLE PROGRAM (SEEN) [TABLE METHOD]: false
  WHOLE PROGRAM (READ) [OBJECT READER METHOD]: false

INLINING OPTION VALUES:
  -inline-factor: 100
  -inline-min-size: 30
  -inline-max-size: 230
  -inline-max-total-size: 2000
  -inline-max-per-routine: 10000
  -inline-max-per-compile: 500000

In the inlining report below:
   "sz" refers to the "size" of the routine. The smaller a routine's size,
      the more likely it is to be inlined.
   "isz" refers to the "inlined size" of the routine. This is the amount
      the calling routine will grow if the called routine is inlined into it.
      The compiler generally limits the amount a routine can grow by having
      routines inlined into it.

Begin optimization report for: STATE_DUMMY

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (STATE_DUMMY) [1/2=50.0%] state_test_offload.F90(10,9)
  -> EXTERN: (10,9) for_set_reentrancy
  -> EXTERN: (44,12) for_random_number
  -> EXTERN: (45,12) for_random_number
  -> EXTERN: (46,12) for_random_number
  -> EXTERN: (47,12) for_random_number
  -> (57,12) STATE_DUMMY:STATE (isz = 861) (sz = 884)
     [[ Unable to inline callsite  <1>]]
  -> EXTERN: (66,7) for_write_seq_lis_xmit
  -> EXTERN: (66,7) for_write_seq_lis


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at state_test_offload.F90(40,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(41,7)
      remark #25420: Collapsed with loop at line 41 
      remark #15388: vectorization support: reference k_3darray has aligned access
      remark #15399: vectorization support: unroll factor set to 4
      remark #15300: LOOP WAS VECTORIZED
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 2 
      remark #15477: vector loop cost: 3.000 
      remark #15478: estimated potential speedup: 2.660 
      remark #15479: lightweight vector operations: 3 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=7857

      LOOP BEGIN at state_test_offload.F90(41,7)
         remark #25421: Loop eliminated in Collapsing 

      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(44,12)
   remark #25095: Loop Interchange not done due to: User Function Inside Loop Nest
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(44,12)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at state_test_offload.F90(44,12)
         remark #15388: vectorization support: reference tmix has aligned access
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector loop cost summary ---
         remark #15476: scalar loop cost: 104 
         remark #15477: vector loop cost: 38.000 
         remark #15478: estimated potential speedup: 2.730 
         remark #15479: lightweight vector operations: 4 
         remark #15480: medium-overhead vector operations: 1 
         remark #15481: heavy-overhead vector operations: 1 
         remark #15482: vectorized math library calls: 1 
         remark #15488: --- end vector loop cost summary ---
         remark #25015: Estimate of max trip count of loop=162
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(45,12)
   remark #25095: Loop Interchange not done due to: User Function Inside Loop Nest
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(45,12)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at state_test_offload.F90(45,12)
         remark #15388: vectorization support: reference tmix1 has aligned access
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector loop cost summary ---
         remark #15476: scalar loop cost: 104 
         remark #15477: vector loop cost: 38.000 
         remark #15478: estimated potential speedup: 2.730 
         remark #15479: lightweight vector operations: 4 
         remark #15480: medium-overhead vector operations: 1 
         remark #15481: heavy-overhead vector operations: 1 
         remark #15482: vectorized math library calls: 1 
         remark #15488: --- end vector loop cost summary ---
         remark #25015: Estimate of max trip count of loop=162
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(46,12)
   remark #25095: Loop Interchange not done due to: User Function Inside Loop Nest
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(46,12)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at state_test_offload.F90(46,12)
         remark #15388: vectorization support: reference tmix2 has aligned access
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector loop cost summary ---
         remark #15476: scalar loop cost: 104 
         remark #15477: vector loop cost: 38.000 
         remark #15478: estimated potential speedup: 2.730 
         remark #15479: lightweight vector operations: 4 
         remark #15480: medium-overhead vector operations: 1 
         remark #15481: heavy-overhead vector operations: 1 
         remark #15482: vectorized math library calls: 1 
         remark #15488: --- end vector loop cost summary ---
         remark #25015: Estimate of max trip count of loop=162
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(47,12)
   remark #25095: Loop Interchange not done due to: User Function Inside Loop Nest
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(47,12)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at state_test_offload.F90(47,12)
         remark #15388: vectorization support: reference tmix3 has aligned access
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector loop cost summary ---
         remark #15476: scalar loop cost: 104 
         remark #15477: vector loop cost: 38.000 
         remark #15478: estimated potential speedup: 2.730 
         remark #15479: lightweight vector operations: 4 
         remark #15480: medium-overhead vector operations: 1 
         remark #15481: heavy-overhead vector operations: 1 
         remark #15482: vectorized math library calls: 1 
         remark #15488: --- end vector loop cost summary ---
         remark #25015: Estimate of max trip count of loop=162
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(49,7)
   remark #25420: Collapsed with loop at line 49 
   remark #25401: memcopy(with guard) generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(49,7)
   <Multiversioned v2>
      remark #15388: vectorization support: reference k_2darray has aligned access
      remark #15388: vectorization support: reference k_3darray has aligned access
      remark #15412: vectorization support: streaming store was generated for K_2DARRAY
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15467: unmasked aligned streaming stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 4 
      remark #15477: vector loop cost: 0.750 
      remark #15478: estimated potential speedup: 5.330 
      remark #15479: lightweight vector operations: 3 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=1885680
   LOOP END

   LOOP BEGIN at state_test_offload.F90(49,7)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(50,7)
   remark #25420: Collapsed with loop at line 50 
   remark #25401: memcopy(with guard) generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(50,7)
   <Multiversioned v2>
      remark #15388: vectorization support: reference ttmix has aligned access
      remark #15388: vectorization support: reference tmix has aligned access
      remark #15412: vectorization support: streaming store was generated for TTMIX
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15467: unmasked aligned streaming stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 4 
      remark #15477: vector loop cost: 1.500 
      remark #15478: estimated potential speedup: 2.660 
      remark #15479: lightweight vector operations: 2 
      remark #15480: medium-overhead vector operations: 1 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=3771360
   LOOP END

   LOOP BEGIN at state_test_offload.F90(50,7)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(51,7)
   remark #25420: Collapsed with loop at line 51 
   remark #25401: memcopy(with guard) generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(51,7)
   <Multiversioned v2>
      remark #15388: vectorization support: reference tempdrdt has aligned access
      remark #15388: vectorization support: reference drdt has aligned access
      remark #15412: vectorization support: streaming store was generated for TEMPDRDT
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15467: unmasked aligned streaming stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 4 
      remark #15477: vector loop cost: 1.500 
      remark #15478: estimated potential speedup: 2.660 
      remark #15479: lightweight vector operations: 2 
      remark #15480: medium-overhead vector operations: 1 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=3771360
   LOOP END

   LOOP BEGIN at state_test_offload.F90(51,7)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(52,7)
   remark #25420: Collapsed with loop at line 52 
   remark #25401: memcopy(with guard) generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(52,7)
   <Multiversioned v2>
      remark #15388: vectorization support: reference tempdrds has aligned access
      remark #15388: vectorization support: reference drds has aligned access
      remark #15412: vectorization support: streaming store was generated for TEMPDRDS
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15467: unmasked aligned streaming stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 4 
      remark #15477: vector loop cost: 1.500 
      remark #15478: estimated potential speedup: 2.660 
      remark #15479: lightweight vector operations: 2 
      remark #15480: medium-overhead vector operations: 1 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=3771360
   LOOP END

   LOOP BEGIN at state_test_offload.F90(52,7)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(53,7)
   remark #25420: Collapsed with loop at line 53 
   remark #25401: memcopy(with guard) generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(53,7)
   <Multiversioned v2>
      remark #15388: vectorization support: reference temptmix1 has aligned access
      remark #15388: vectorization support: reference tmix1 has aligned access
      remark #15412: vectorization support: streaming store was generated for TEMPTMIX1
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15467: unmasked aligned streaming stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 4 
      remark #15477: vector loop cost: 1.500 
      remark #15478: estimated potential speedup: 2.660 
      remark #15479: lightweight vector operations: 2 
      remark #15480: medium-overhead vector operations: 1 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=3771360
   LOOP END

   LOOP BEGIN at state_test_offload.F90(53,7)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(54,7)
   remark #25420: Collapsed with loop at line 54 
   remark #25401: memcopy(with guard) generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(54,7)
   <Multiversioned v2>
      remark #15388: vectorization support: reference temptmix2 has aligned access
      remark #15388: vectorization support: reference tmix2 has aligned access
      remark #15412: vectorization support: streaming store was generated for TEMPTMIX2
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15467: unmasked aligned streaming stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 4 
      remark #15477: vector loop cost: 1.500 
      remark #15478: estimated potential speedup: 2.660 
      remark #15479: lightweight vector operations: 2 
      remark #15480: medium-overhead vector operations: 1 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=3771360
   LOOP END

   LOOP BEGIN at state_test_offload.F90(54,7)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(56,7)
   remark #15382: vectorization support: call to function STATE_DUMMY:STATE cannot be vectorized   [ state_test_offload.F90(57,12) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #25436: completely unrolled by 10  
LOOP END

LOOP BEGIN at state_test_offload.F90(60,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #25420: Collapsed with loop at line 60 
   remark #25420: Collapsed with loop at line 60 
   remark #25401: memcopy(with guard) generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(60,7)
   <Multiversioned v2>
      remark #15388: vectorization support: reference tmix has aligned access
      remark #15388: vectorization support: reference ttmix has aligned access
      remark #15412: vectorization support: streaming store was generated for TMIX
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15467: unmasked aligned streaming stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 4 
      remark #15477: vector loop cost: 1.500 
      remark #15478: estimated potential speedup: 2.660 
      remark #15479: lightweight vector operations: 2 
      remark #15480: medium-overhead vector operations: 1 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=3771360
   LOOP END

   LOOP BEGIN at state_test_offload.F90(60,7)
      remark #25421: Loop eliminated in Collapsing 


      LOOP BEGIN at state_test_offload.F90(60,7)
         remark #25421: Loop eliminated in Collapsing 

      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(61,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #25420: Collapsed with loop at line 61 
   remark #25420: Collapsed with loop at line 61 
   remark #25401: memcopy(with guard) generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(61,7)
   <Multiversioned v2>
      remark #15388: vectorization support: reference drdt has aligned access
      remark #15388: vectorization support: reference tempdrdt has aligned access
      remark #15412: vectorization support: streaming store was generated for DRDT
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15467: unmasked aligned streaming stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 4 
      remark #15477: vector loop cost: 1.500 
      remark #15478: estimated potential speedup: 2.660 
      remark #15479: lightweight vector operations: 2 
      remark #15480: medium-overhead vector operations: 1 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=3771360
   LOOP END

   LOOP BEGIN at state_test_offload.F90(61,7)
      remark #25421: Loop eliminated in Collapsing 


      LOOP BEGIN at state_test_offload.F90(61,7)
         remark #25421: Loop eliminated in Collapsing 

      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(62,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #25420: Collapsed with loop at line 62 
   remark #25420: Collapsed with loop at line 62 
   remark #25401: memcopy(with guard) generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(62,7)
   <Multiversioned v2>
      remark #15388: vectorization support: reference drds has aligned access
      remark #15388: vectorization support: reference tempdrds has aligned access
      remark #15412: vectorization support: streaming store was generated for DRDS
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15467: unmasked aligned streaming stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 4 
      remark #15477: vector loop cost: 1.500 
      remark #15478: estimated potential speedup: 2.660 
      remark #15479: lightweight vector operations: 2 
      remark #15480: medium-overhead vector operations: 1 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=3771360
   LOOP END

   LOOP BEGIN at state_test_offload.F90(62,7)
      remark #25421: Loop eliminated in Collapsing 


      LOOP BEGIN at state_test_offload.F90(62,7)
         remark #25421: Loop eliminated in Collapsing 

      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(63,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #25420: Collapsed with loop at line 63 
   remark #25420: Collapsed with loop at line 63 
   remark #25401: memcopy(with guard) generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(63,7)
   <Multiversioned v2>
      remark #15388: vectorization support: reference tmix1 has aligned access
      remark #15388: vectorization support: reference temptmix1 has aligned access
      remark #15412: vectorization support: streaming store was generated for TMIX1
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15467: unmasked aligned streaming stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 4 
      remark #15477: vector loop cost: 1.500 
      remark #15478: estimated potential speedup: 2.660 
      remark #15479: lightweight vector operations: 2 
      remark #15480: medium-overhead vector operations: 1 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=3771360
   LOOP END

   LOOP BEGIN at state_test_offload.F90(63,7)
      remark #25421: Loop eliminated in Collapsing 


      LOOP BEGIN at state_test_offload.F90(63,7)
         remark #25421: Loop eliminated in Collapsing 

      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(64,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #25420: Collapsed with loop at line 64 
   remark #25420: Collapsed with loop at line 64 
   remark #25401: memcopy(with guard) generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(64,7)
   <Multiversioned v2>
      remark #15388: vectorization support: reference tmix2 has aligned access
      remark #15388: vectorization support: reference temptmix2 has aligned access
      remark #15412: vectorization support: streaming store was generated for TMIX2
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15467: unmasked aligned streaming stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 4 
      remark #15477: vector loop cost: 1.500 
      remark #15478: estimated potential speedup: 2.660 
      remark #15479: lightweight vector operations: 2 
      remark #15480: medium-overhead vector operations: 1 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=3771360
   LOOP END

   LOOP BEGIN at state_test_offload.F90(64,7)
      remark #25421: Loop eliminated in Collapsing 


      LOOP BEGIN at state_test_offload.F90(64,7)
         remark #25421: Loop eliminated in Collapsing 

      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(66,32)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #25420: Collapsed with loop at line 66 
   remark #25420: Collapsed with loop at line 66 
   remark #15388: vectorization support: reference drdt has aligned access
   remark #15399: vectorization support: unroll factor set to 8
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 6 
   remark #15477: vector loop cost: 20.000 
   remark #15478: estimated potential speedup: 2.390 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=471420

   LOOP BEGIN at state_test_offload.F90(66,32)
      remark #25421: Loop eliminated in Collapsing 


      LOOP BEGIN at state_test_offload.F90(66,32)
         remark #25421: Loop eliminated in Collapsing 

      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

state_test_offload.F90(49,7):remark #34026: call to memcpy implemented as a call to optimized library version
state_test_offload.F90(50,7):remark #34026: call to memcpy implemented as a call to optimized library version
state_test_offload.F90(51,7):remark #34026: call to memcpy implemented as a call to optimized library version
state_test_offload.F90(52,7):remark #34026: call to memcpy implemented as a call to optimized library version
state_test_offload.F90(53,7):remark #34026: call to memcpy implemented as a call to optimized library version
state_test_offload.F90(54,7):remark #34026: call to memcpy implemented as a call to optimized library version
state_test_offload.F90(60,7):remark #34026: call to memcpy implemented as a call to optimized library version
state_test_offload.F90(61,7):remark #34026: call to memcpy implemented as a call to optimized library version
state_test_offload.F90(62,7):remark #34026: call to memcpy implemented as a call to optimized library version
state_test_offload.F90(63,7):remark #34026: call to memcpy implemented as a call to optimized library version
state_test_offload.F90(64,7):remark #34026: call to memcpy implemented as a call to optimized library version
===========================================================================

Begin optimization report for: STATE_DUMMY:STATE

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (STATE_DUMMY:STATE) [2/2=100.0%] state_test_offload.F90(71,12)
  -> EXTERN: (162,12) for_random_number
  -> EXTERN: (171,41) __powr8i4
  -> EXTERN: (197,20) omp_get_wtime
  -> EXTERN: (280,18) omp_get_wtime
  -> EXTERN: (284,7) for_write_seq_lis_xmit
  -> EXTERN: (284,7) for_write_seq_lis
  -> EXTERN: (286,7) for_write_seq_lis
  -> EXTERN: (287,7) for_write_seq_lis
  -> EXTERN: (288,7) for_write_seq_lis
  -> EXTERN: (289,7) for_write_seq_lis
  -> EXTERN: (290,7) for_write_seq_lis
  -> EXTERN: (291,7) for_write_seq_lis
  -> EXTERN: (292,7) for_write_seq_lis
  -> EXTERN: (293,7) for_write_seq_lis


    Report from: OpenMP optimizations [openmp]

OpenMP Construct at state_test_offload.F90(207,7)
   remark #16201: OpenMP DEFINED REGION WAS PARALLELIZED

    Report from: Offload optimizations [offload]

OFFLOAD:state(194,1):  Offload to target MIC <expr>
 Evaluate length/align/alloc_if/free_if/alloc/into expressions
 Data sent from host to target
       first_time, scalar size 8 bytes
       saltk, pointer to data with element count specified in pragma
       rhoout, pointer to data with element count specified in pragma
       rhofull, pointer to data with element count specified in pragma
       drhodt, pointer to data with element count specified in pragma
       drhods, pointer to data with element count specified in pragma
       tempk, pointer to data with element count specified in pragma
       __offload_stack_ptr_state$WORK1$_6_V$b1.0, pointer to array reference expression with base
       __offload_stack_ptr_state$WORK2$_6_V$b0.0, pointer to array reference expression with base
       __offload_stack_ptr_state$WORK3$_6_V$af.0, pointer to array reference expression with base
       __offload_stack_ptr_state$WORK4$_6_V$ae.0, pointer to array reference expression with base
       __offload_stack_ptr_state$MWJFNUMS0T0$_6_V$93.0, pointer to array reference expression with base
       __offload_stack_ptr_state$MWJFNUMS0T2$_6_V$92.0, pointer to array reference expression with base
       __offload_stack_ptr_state$MWJFNUMS1T0$_6_V$91.0, pointer to array reference expression with base
       __offload_stack_ptr_state$MWJFDENS0T0$_6_V$90.0, pointer to array reference expression with base
       __offload_stack_ptr_state$MWJFDENS0T1$_6_V$8f.0, pointer to array reference expression with base
       __offload_stack_ptr_state$MWJFDENS0T3$_6_V$8e.0, pointer to array reference expression with base
       __offload_stack_ptr_state$TMAX$_6_V$a4.0, pointer to array reference expression with base
       __offload_stack_ptr_state$TMIN$_6_V$a5.0, pointer to array reference expression with base
       __offload_stack_ptr_state$SMAX$_6_V$a2.0, pointer to array reference expression with base
       __offload_stack_ptr_state$SMIN$_6_V$a3.0, pointer to array reference expression with base
       kk, pointer to data with element count specified in pragma
       mwjfnums0t1, scalar size 8 bytes
       mwjfnums0t3, scalar size 8 bytes
       mwjfnums1t1, scalar size 8 bytes
       mwjfnums2t0, scalar size 8 bytes
       mwjfdens0t2, scalar size 8 bytes
       mwjfdens0t4, scalar size 8 bytes
       mwjfdens1t0, scalar size 8 bytes
       mwjfdens1t1, scalar size 8 bytes
       mwjfdens1t3, scalar size 8 bytes
       mwjfdensqt0, scalar size 8 bytes
       mwjfdensqt2, scalar size 8 bytes
       twork1, scalar size 8 bytes
       twork2, scalar size 8 bytes
       twork3, scalar size 8 bytes
       twork4, scalar size 8 bytes
       tdenomk, scalar size 8 bytes
       tq, scalar size 8 bytes
       sq, scalar size 8 bytes
       sqr, scalar size 8 bytes
       j, scalar size 4 bytes
       i, scalar size 4 bytes
       end_time, scalar size 8 bytes
 Data received by host from target
       first_time, scalar size 8 bytes
       rhoout, pointer to data with element count specified in pragma
       rhofull, pointer to data with element count specified in pragma
       drhodt, pointer to data with element count specified in pragma
       drhods, pointer to data with element count specified in pragma
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       mwjfnums0t1, scalar size 8 bytes
       mwjfnums0t3, scalar size 8 bytes
       mwjfnums1t1, scalar size 8 bytes
       mwjfnums2t0, scalar size 8 bytes
       mwjfdens0t2, scalar size 8 bytes
       mwjfdens0t4, scalar size 8 bytes
       mwjfdens1t0, scalar size 8 bytes
       mwjfdens1t1, scalar size 8 bytes
       mwjfdens1t3, scalar size 8 bytes
       mwjfdensqt0, scalar size 8 bytes
       mwjfdensqt2, scalar size 8 bytes
       twork1, scalar size 8 bytes
       twork2, scalar size 8 bytes
       twork3, scalar size 8 bytes
       twork4, scalar size 8 bytes
       tdenomk, scalar size 8 bytes
       tq, scalar size 8 bytes
       sq, scalar size 8 bytes
       sqr, scalar size 8 bytes
       j, scalar size 4 bytes
       i, scalar size 4 bytes
       end_time, scalar size 8 bytes


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at state_test_offload.F90(157,7)
   remark #15388: vectorization support: reference tmin has aligned access
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 4 
   remark #15477: vector loop cost: 3.000 
   remark #15478: estimated potential speedup: 2.660 
   remark #15479: lightweight vector operations: 2 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=15
LOOP END

LOOP BEGIN at state_test_offload.F90(158,7)
   remark #15388: vectorization support: reference tmax has aligned access
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 4 
   remark #15477: vector loop cost: 3.000 
   remark #15478: estimated potential speedup: 2.660 
   remark #15479: lightweight vector operations: 2 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=15
LOOP END

LOOP BEGIN at state_test_offload.F90(159,7)
   remark #25408: memset generated
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy
LOOP END

LOOP BEGIN at state_test_offload.F90(160,7)
   remark #15388: vectorization support: reference smax has aligned access
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 4 
   remark #15477: vector loop cost: 3.000 
   remark #15478: estimated potential speedup: 2.660 
   remark #15479: lightweight vector operations: 2 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=15
LOOP END

LOOP BEGIN at state_test_offload.F90(162,12)
   remark #15388: vectorization support: reference pressz has aligned access
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 104 
   remark #15477: vector loop cost: 38.000 
   remark #15478: estimated potential speedup: 2.730 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15481: heavy-overhead vector operations: 1 
   remark #15482: vectorized math library calls: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=30
LOOP END

LOOP BEGIN at state_test_offload.F90(164,7)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ state_test_offload.F90(174,7) ]
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(165,7)
      remark #25084: Preprocess Loopnests: Moving Out Store    [ state_test_offload.F90(173,7) ]
      remark #15388: vectorization support: reference k_2darray has aligned access   [ state_test_offload.F90(166,7) ]
      remark #15388: vectorization support: reference _6.0.2_ptr.var has aligned access   [ state_test_offload.F90(167,7) ]
      remark #15388: vectorization support: reference _6.0.2_ptr.var has aligned access   [ state_test_offload.F90(168,7) ]
      remark #15388: vectorization support: reference _6.0.2_ptr.var has aligned access   [ state_test_offload.F90(169,7) ]
      remark #15388: vectorization support: reference _6.0.2_ptr.var has aligned access   [ state_test_offload.F90(170,7) ]
      remark #15388: vectorization support: reference _6.0.2_ptr.var has aligned access   [ state_test_offload.F90(171,7) ]
      remark #15388: vectorization support: reference _6.0.2_ptr.var has aligned access   [ state_test_offload.F90(172,7) ]
      remark #15300: LOOP WAS VECTORIZED
      remark #15449: unmasked aligned unit stride stores: 6 
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15458: masked indexed (or gather) loads: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 77 
      remark #15477: vector loop cost: 40.000 
      remark #15478: estimated potential speedup: 1.920 
      remark #15479: lightweight vector operations: 59 
      remark #15480: medium-overhead vector operations: 2 
      remark #15481: heavy-overhead vector operations: 1 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=1440
   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(286,16)
   remark #25420: Collapsed with loop at line 286 
   remark #15388: vectorization support: reference _6.0.2_ptr.var has aligned access
   remark #15399: vectorization support: unroll factor set to 8
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 6 
   remark #15477: vector loop cost: 20.000 
   remark #15478: estimated potential speedup: 2.390 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=471420

   LOOP BEGIN at state_test_offload.F90(286,16)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(287,16)
   remark #25420: Collapsed with loop at line 287 
   remark #15388: vectorization support: reference _6.0.2_ptr.var has aligned access
   remark #15399: vectorization support: unroll factor set to 8
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 6 
   remark #15477: vector loop cost: 20.000 
   remark #15478: estimated potential speedup: 2.390 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=471420

   LOOP BEGIN at state_test_offload.F90(287,16)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(288,16)
   remark #25420: Collapsed with loop at line 288 
   remark #15388: vectorization support: reference _6.0.2_ptr.var has aligned access
   remark #15399: vectorization support: unroll factor set to 8
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 6 
   remark #15477: vector loop cost: 20.000 
   remark #15478: estimated potential speedup: 2.390 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=471420

   LOOP BEGIN at state_test_offload.F90(288,16)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(289,16)
   remark #25420: Collapsed with loop at line 289 
   remark #15388: vectorization support: reference _6.0.2_ptr.var has aligned access
   remark #15399: vectorization support: unroll factor set to 8
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 6 
   remark #15477: vector loop cost: 20.000 
   remark #15478: estimated potential speedup: 2.390 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=471420

   LOOP BEGIN at state_test_offload.F90(289,16)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(290,16)
<Peeled>
LOOP END

LOOP BEGIN at state_test_offload.F90(290,16)
   remark #25420: Collapsed with loop at line 290 
   remark #15388: vectorization support: reference drhods has aligned access
   remark #15399: vectorization support: unroll factor set to 8
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 6 
   remark #15477: vector loop cost: 20.000 
   remark #15478: estimated potential speedup: 2.390 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=471420

   LOOP BEGIN at state_test_offload.F90(290,16)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(290,16)
<Remainder>
   remark #15388: vectorization support: reference drhods has aligned access
   remark #15301: REMAINDER LOOP WAS VECTORIZED
LOOP END

LOOP BEGIN at state_test_offload.F90(290,16)
<Remainder>
LOOP END

LOOP BEGIN at state_test_offload.F90(291,16)
<Peeled>
LOOP END

LOOP BEGIN at state_test_offload.F90(291,16)
   remark #25420: Collapsed with loop at line 291 
   remark #15388: vectorization support: reference drhodt has aligned access
   remark #15399: vectorization support: unroll factor set to 8
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 6 
   remark #15477: vector loop cost: 20.000 
   remark #15478: estimated potential speedup: 2.390 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=471420

   LOOP BEGIN at state_test_offload.F90(291,16)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(291,16)
<Remainder>
   remark #15388: vectorization support: reference drhodt has aligned access
   remark #15301: REMAINDER LOOP WAS VECTORIZED
LOOP END

LOOP BEGIN at state_test_offload.F90(291,16)
<Remainder>
LOOP END

LOOP BEGIN at state_test_offload.F90(292,16)
<Peeled>
LOOP END

LOOP BEGIN at state_test_offload.F90(292,16)
   remark #25420: Collapsed with loop at line 292 
   remark #15388: vectorization support: reference rhoout has aligned access
   remark #15399: vectorization support: unroll factor set to 8
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 6 
   remark #15477: vector loop cost: 20.000 
   remark #15478: estimated potential speedup: 2.390 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=471420

   LOOP BEGIN at state_test_offload.F90(292,16)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(292,16)
<Remainder>
   remark #15388: vectorization support: reference rhoout has aligned access
   remark #15301: REMAINDER LOOP WAS VECTORIZED
LOOP END

LOOP BEGIN at state_test_offload.F90(292,16)
<Remainder>
LOOP END

LOOP BEGIN at state_test_offload.F90(293,16)
<Peeled>
LOOP END

LOOP BEGIN at state_test_offload.F90(293,16)
   remark #25420: Collapsed with loop at line 293 
   remark #15388: vectorization support: reference rhofull has aligned access
   remark #15399: vectorization support: unroll factor set to 8
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 6 
   remark #15477: vector loop cost: 20.000 
   remark #15478: estimated potential speedup: 2.390 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=471420

   LOOP BEGIN at state_test_offload.F90(293,16)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(293,16)
<Remainder>
   remark #15388: vectorization support: reference rhofull has aligned access
   remark #15301: REMAINDER LOOP WAS VECTORIZED
LOOP END

LOOP BEGIN at state_test_offload.F90(293,16)
<Remainder>
LOOP END

    Report from: Code generation optimizations [cg]

state_test_offload.F90(159,7):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (64, 0)
state_test_offload.F90(194,1):remark #34026: call to memcpy implemented as a call to optimized library version
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
===========================================================================

    Report from: Interprocedural optimizations [ipo]

INLINING FOOTNOTES:

<1> Inlining the subprogram will lead to incorrect program behavior.


    Report from: Interprocedural optimizations [ipo]

  WHOLE PROGRAM (SAFE) [EITHER METHOD]: false
  WHOLE PROGRAM (SEEN) [TABLE METHOD]: false
  WHOLE PROGRAM (READ) [OBJECT READER METHOD]: false

INLINING OPTION VALUES:
  -inline-factor: 100
  -inline-min-size: 30
  -inline-max-size: 230
  -inline-max-total-size: 2000
  -inline-max-per-routine: 10000
  -inline-max-per-compile: 500000

In the inlining report below:
   "sz" refers to the "size" of the routine. The smaller a routine's size,
      the more likely it is to be inlined.
   "isz" refers to the "inlined size" of the routine. This is the amount
      the calling routine will grow if the called routine is inlined into it.
      The compiler generally limits the amount a routine can grow by having
      routines inlined into it.

*MIC* Begin optimization report for: STATE_DUMMY

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (STATE_DUMMY) [1/2=50.0%] state_test_offload.F90(10,9)
  -> EXTERN: (10,9) for_set_reentrancy
  -> EXTERN: (44,12) for_random_number
  -> EXTERN: (45,12) for_random_number
  -> EXTERN: (46,12) for_random_number
  -> EXTERN: (47,12) for_random_number
  -> (57,12) STATE_DUMMY:STATE (isz = 861) (sz = 884)
     [[ Unable to inline callsite  <1>]]
  -> EXTERN: (66,7) for_write_seq_lis_xmit
  -> EXTERN: (66,7) for_write_seq_lis

===========================================================================

*MIC* Begin optimization report for: STATE_DUMMY:STATE

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (STATE_DUMMY:STATE) [2/2=100.0%] state_test_offload.F90(71,12)
  -> EXTERN: (162,12) for_random_number
  -> EXTERN: (171,41) __powr8i4
  -> EXTERN: (197,20) omp_get_wtime
  -> EXTERN: (280,18) omp_get_wtime
  -> EXTERN: (284,7) for_write_seq_lis_xmit
  -> EXTERN: (284,7) for_write_seq_lis
  -> EXTERN: (286,7) for_write_seq_lis
  -> EXTERN: (287,7) for_write_seq_lis
  -> EXTERN: (288,7) for_write_seq_lis
  -> EXTERN: (289,7) for_write_seq_lis
  -> EXTERN: (290,7) for_write_seq_lis
  -> EXTERN: (291,7) for_write_seq_lis
  -> EXTERN: (292,7) for_write_seq_lis
  -> EXTERN: (293,7) for_write_seq_lis


    Report from: OpenMP optimizations [openmp]

OpenMP Construct at state_test_offload.F90(207,7)
   remark #16201: OpenMP DEFINED REGION WAS PARALLELIZED

    Report from: Offload optimizations [offload]

OFFLOAD:state_dummy_IP_state_(194,1):  Outlined offload region
 Data received by target from host
       first_time, scalar size 8 bytes
       saltk, pointer to data with element count specified in pragma
       rhoout, pointer to data with element count specified in pragma
       rhofull, pointer to data with element count specified in pragma
       drhodt, pointer to data with element count specified in pragma
       drhods, pointer to data with element count specified in pragma
       tempk, pointer to data with element count specified in pragma
       __offload_stack_ptr_state$WORK1$_6_V$b1.0, pointer to array reference expression with base
       __offload_stack_ptr_state$WORK2$_6_V$b0.0, pointer to array reference expression with base
       __offload_stack_ptr_state$WORK3$_6_V$af.0, pointer to array reference expression with base
       __offload_stack_ptr_state$WORK4$_6_V$ae.0, pointer to array reference expression with base
       __offload_stack_ptr_state$MWJFNUMS0T0$_6_V$93.0, pointer to array reference expression with base
       __offload_stack_ptr_state$MWJFNUMS0T2$_6_V$92.0, pointer to array reference expression with base
       __offload_stack_ptr_state$MWJFNUMS1T0$_6_V$91.0, pointer to array reference expression with base
       __offload_stack_ptr_state$MWJFDENS0T0$_6_V$90.0, pointer to array reference expression with base
       __offload_stack_ptr_state$MWJFDENS0T1$_6_V$8f.0, pointer to array reference expression with base
       __offload_stack_ptr_state$MWJFDENS0T3$_6_V$8e.0, pointer to array reference expression with base
       __offload_stack_ptr_state$TMAX$_6_V$a4.0, pointer to array reference expression with base
       __offload_stack_ptr_state$TMIN$_6_V$a5.0, pointer to array reference expression with base
       __offload_stack_ptr_state$SMAX$_6_V$a2.0, pointer to array reference expression with base
       __offload_stack_ptr_state$SMIN$_6_V$a3.0, pointer to array reference expression with base
       kk, pointer to data with element count specified in pragma
       mwjfnums0t1, scalar size 8 bytes
       mwjfnums0t3, scalar size 8 bytes
       mwjfnums1t1, scalar size 8 bytes
       mwjfnums2t0, scalar size 8 bytes
       mwjfdens0t2, scalar size 8 bytes
       mwjfdens0t4, scalar size 8 bytes
       mwjfdens1t0, scalar size 8 bytes
       mwjfdens1t1, scalar size 8 bytes
       mwjfdens1t3, scalar size 8 bytes
       mwjfdensqt0, scalar size 8 bytes
       mwjfdensqt2, scalar size 8 bytes
       twork1, scalar size 8 bytes
       twork2, scalar size 8 bytes
       twork3, scalar size 8 bytes
       twork4, scalar size 8 bytes
       tdenomk, scalar size 8 bytes
       tq, scalar size 8 bytes
       sq, scalar size 8 bytes
       sqr, scalar size 8 bytes
       j, scalar size 4 bytes
       i, scalar size 4 bytes
       end_time, scalar size 8 bytes
 Data sent from target to host
       first_time, scalar size 8 bytes
       rhoout, pointer to data with element count specified in pragma
       rhofull, pointer to data with element count specified in pragma
       drhodt, pointer to data with element count specified in pragma
       drhods, pointer to data with element count specified in pragma
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.48, pointer to array reference expression with base
       mwjfnums0t1, scalar size 8 bytes
       mwjfnums0t3, scalar size 8 bytes
       mwjfnums1t1, scalar size 8 bytes
       mwjfnums2t0, scalar size 8 bytes
       mwjfdens0t2, scalar size 8 bytes
       mwjfdens0t4, scalar size 8 bytes
       mwjfdens1t0, scalar size 8 bytes
       mwjfdens1t1, scalar size 8 bytes
       mwjfdens1t3, scalar size 8 bytes
       mwjfdensqt0, scalar size 8 bytes
       mwjfdensqt2, scalar size 8 bytes
       twork1, scalar size 8 bytes
       twork2, scalar size 8 bytes
       twork3, scalar size 8 bytes
       twork4, scalar size 8 bytes
       tdenomk, scalar size 8 bytes
       tq, scalar size 8 bytes
       sq, scalar size 8 bytes
       sqr, scalar size 8 bytes
       j, scalar size 4 bytes
       i, scalar size 4 bytes
       end_time, scalar size 8 bytes


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at state_test_offload.F90(219,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(223,7)
   <Predicate Optimized v7>
      remark #25422: Invariant Condition at line 243 hoisted out of this loop
      remark #25422: Invariant Condition at line 247 hoisted out of this loop
      remark #25422: Invariant Condition at line 251 hoisted out of this loop
      remark #25422: Invariant Condition at line 265 hoisted out of this loop
      remark #15388: vectorization support: reference tempk has aligned access   [ state_test_offload.F90(226,7) ]
      remark #15388: vectorization support: reference saltk has aligned access   [ state_test_offload.F90(229,7) ]
      remark #15388: vectorization support: reference mwjfnums0t0 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfnums0t2 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfnums1t0 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfdens0t0 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference mwjfdens0t1 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference mwjfdens0t3 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference rhoout has aligned access   [ state_test_offload.F90(244,11) ]
      remark #15388: vectorization support: reference rhofull has aligned access   [ state_test_offload.F90(248,11) ]
      remark #15388: vectorization support: reference drhodt has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15388: vectorization support: reference mwjfnums0t2 has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15388: vectorization support: reference mwjfdens0t1 has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15388: vectorization support: reference mwjfdens0t3 has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15388: vectorization support: reference drhods has aligned access   [ state_test_offload.F90(273,10) ]
      remark #15388: vectorization support: reference mwjfnums1t0 has aligned access   [ state_test_offload.F90(273,10) ]
      remark #15412: vectorization support: streaming store was generated for rhoout   [ state_test_offload.F90(244,11) ]
      remark #15412: vectorization support: streaming store was generated for rhofull   [ state_test_offload.F90(248,11) ]
      remark #15412: vectorization support: streaming store was generated for drhodt   [ state_test_offload.F90(262,11) ]
      remark #15412: vectorization support: streaming store was generated for drhods   [ state_test_offload.F90(273,10) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15467: unmasked aligned streaming stores: 4 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 330 
      remark #15477: vector loop cost: 50.870 
      remark #15478: estimated potential speedup: 6.480 
      remark #15479: lightweight vector operations: 200 
      remark #15488: --- end vector loop cost summary ---
      remark #25018: Total number of lines prefetched=16
      remark #25019: Number of spatial prefetches=16, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(225,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(227,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,61) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(233,42) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(236,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(236,41) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(237,18) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END

   LOOP BEGIN at state_test_offload.F90(223,7)
   <Predicate Optimized v8>
      remark #15388: vectorization support: reference tempk has aligned access   [ state_test_offload.F90(226,7) ]
      remark #15388: vectorization support: reference saltk has aligned access   [ state_test_offload.F90(229,7) ]
      remark #15388: vectorization support: reference mwjfnums0t0 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfnums0t2 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfnums1t0 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfdens0t0 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference mwjfdens0t1 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference mwjfdens0t3 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference rhoout has aligned access   [ state_test_offload.F90(244,11) ]
      remark #15388: vectorization support: reference rhofull has aligned access   [ state_test_offload.F90(248,11) ]
      remark #15388: vectorization support: reference drhodt has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15388: vectorization support: reference mwjfnums0t2 has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15388: vectorization support: reference mwjfdens0t1 has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15388: vectorization support: reference mwjfdens0t3 has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15412: vectorization support: streaming store was generated for rhoout   [ state_test_offload.F90(244,11) ]
      remark #15412: vectorization support: streaming store was generated for rhofull   [ state_test_offload.F90(248,11) ]
      remark #15412: vectorization support: streaming store was generated for drhodt   [ state_test_offload.F90(262,11) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15467: unmasked aligned streaming stores: 3 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 274 
      remark #15477: vector loop cost: 40.620 
      remark #15478: estimated potential speedup: 6.740 
      remark #15479: lightweight vector operations: 157 
      remark #15488: --- end vector loop cost summary ---
      remark #25018: Total number of lines prefetched=16
      remark #25019: Number of spatial prefetches=16, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(225,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(227,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,61) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(233,42) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(236,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(236,41) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(237,18) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END

   LOOP BEGIN at state_test_offload.F90(223,7)
   <Predicate Optimized v9>
      remark #25422: Invariant Condition at line 265 hoisted out of this loop
      remark #15388: vectorization support: reference tempk has aligned access   [ state_test_offload.F90(226,7) ]
      remark #15388: vectorization support: reference saltk has aligned access   [ state_test_offload.F90(229,7) ]
      remark #15388: vectorization support: reference mwjfnums0t0 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfnums0t2 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfnums1t0 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfdens0t0 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference mwjfdens0t1 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference mwjfdens0t3 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference rhoout has aligned access   [ state_test_offload.F90(244,11) ]
      remark #15388: vectorization support: reference rhofull has aligned access   [ state_test_offload.F90(248,11) ]
      remark #15388: vectorization support: reference drhods has aligned access   [ state_test_offload.F90(273,10) ]
      remark #15388: vectorization support: reference mwjfnums1t0 has aligned access   [ state_test_offload.F90(273,10) ]
      remark #15412: vectorization support: streaming store was generated for rhoout   [ state_test_offload.F90(244,11) ]
      remark #15412: vectorization support: streaming store was generated for rhofull   [ state_test_offload.F90(248,11) ]
      remark #15412: vectorization support: streaming store was generated for drhods   [ state_test_offload.F90(273,10) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15467: unmasked aligned streaming stores: 3 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 256 
      remark #15477: vector loop cost: 38.000 
      remark #15478: estimated potential speedup: 6.730 
      remark #15479: lightweight vector operations: 145 
      remark #15488: --- end vector loop cost summary ---
      remark #25018: Total number of lines prefetched=16
      remark #25019: Number of spatial prefetches=16, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(225,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(227,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,61) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(233,42) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(236,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(236,41) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(237,18) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END

   LOOP BEGIN at state_test_offload.F90(223,7)
   <Predicate Optimized v10>
      remark #15388: vectorization support: reference tempk has aligned access   [ state_test_offload.F90(226,7) ]
      remark #15388: vectorization support: reference saltk has aligned access   [ state_test_offload.F90(229,7) ]
      remark #15388: vectorization support: reference mwjfnums0t0 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfnums0t2 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfnums1t0 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfdens0t0 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference mwjfdens0t1 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference mwjfdens0t3 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference rhoout has aligned access   [ state_test_offload.F90(244,11) ]
      remark #15388: vectorization support: reference rhofull has aligned access   [ state_test_offload.F90(248,11) ]
      remark #15412: vectorization support: streaming store was generated for rhoout   [ state_test_offload.F90(244,11) ]
      remark #15412: vectorization support: streaming store was generated for rhofull   [ state_test_offload.F90(248,11) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15467: unmasked aligned streaming stores: 2 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 200 
      remark #15477: vector loop cost: 27.750 
      remark #15478: estimated potential speedup: 7.200 
      remark #15479: lightweight vector operations: 102 
      remark #15488: --- end vector loop cost summary ---
      remark #25018: Total number of lines prefetched=16
      remark #25019: Number of spatial prefetches=16, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(225,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(227,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,61) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(233,42) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(236,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(236,41) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(237,18) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END

   LOOP BEGIN at state_test_offload.F90(223,7)
   <Predicate Optimized v13>
      remark #25422: Invariant Condition at line 251 hoisted out of this loop
      remark #25422: Invariant Condition at line 265 hoisted out of this loop
      remark #15388: vectorization support: reference tempk has aligned access   [ state_test_offload.F90(226,7) ]
      remark #15388: vectorization support: reference saltk has aligned access   [ state_test_offload.F90(229,7) ]
      remark #15388: vectorization support: reference mwjfnums0t0 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfnums0t2 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfnums1t0 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfdens0t0 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference mwjfdens0t1 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference mwjfdens0t3 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference rhoout has aligned access   [ state_test_offload.F90(244,11) ]
      remark #15388: vectorization support: reference drhodt has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15388: vectorization support: reference mwjfnums0t2 has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15388: vectorization support: reference mwjfdens0t1 has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15388: vectorization support: reference mwjfdens0t3 has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15388: vectorization support: reference drhods has aligned access   [ state_test_offload.F90(273,10) ]
      remark #15388: vectorization support: reference mwjfnums1t0 has aligned access   [ state_test_offload.F90(273,10) ]
      remark #15412: vectorization support: streaming store was generated for rhoout   [ state_test_offload.F90(244,11) ]
      remark #15412: vectorization support: streaming store was generated for drhodt   [ state_test_offload.F90(262,11) ]
      remark #15412: vectorization support: streaming store was generated for drhods   [ state_test_offload.F90(273,10) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15467: unmasked aligned streaming stores: 3 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 324 
      remark #15477: vector loop cost: 49.870 
      remark #15478: estimated potential speedup: 6.490 
      remark #15479: lightweight vector operations: 195 
      remark #15488: --- end vector loop cost summary ---
      remark #25018: Total number of lines prefetched=16
      remark #25019: Number of spatial prefetches=16, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(225,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(227,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,61) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(233,42) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(236,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(236,41) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(237,18) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END

   LOOP BEGIN at state_test_offload.F90(223,7)
   <Predicate Optimized v14>
      remark #15388: vectorization support: reference tempk has aligned access   [ state_test_offload.F90(226,7) ]
      remark #15388: vectorization support: reference saltk has aligned access   [ state_test_offload.F90(229,7) ]
      remark #15388: vectorization support: reference mwjfnums0t0 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfnums0t2 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfnums1t0 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfdens0t0 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference mwjfdens0t1 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference mwjfdens0t3 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference rhoout has aligned access   [ state_test_offload.F90(244,11) ]
      remark #15388: vectorization support: reference drhodt has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15388: vectorization support: reference mwjfnums0t2 has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15388: vectorization support: reference mwjfdens0t1 has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15388: vectorization support: reference mwjfdens0t3 has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15412: vectorization support: streaming store was generated for rhoout   [ state_test_offload.F90(244,11) ]
      remark #15412: vectorization support: streaming store was generated for drhodt   [ state_test_offload.F90(262,11) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15467: unmasked aligned streaming stores: 2 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 268 
      remark #15477: vector loop cost: 39.620 
      remark #15478: estimated potential speedup: 6.760 
      remark #15479: lightweight vector operations: 152 
      remark #15488: --- end vector loop cost summary ---
      remark #25018: Total number of lines prefetched=16
      remark #25019: Number of spatial prefetches=16, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(225,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(227,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,61) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(233,42) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(236,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(236,41) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(237,18) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END

   LOOP BEGIN at state_test_offload.F90(223,7)
   <Predicate Optimized v15>
      remark #25422: Invariant Condition at line 265 hoisted out of this loop
      remark #15388: vectorization support: reference tempk has aligned access   [ state_test_offload.F90(226,7) ]
      remark #15388: vectorization support: reference saltk has aligned access   [ state_test_offload.F90(229,7) ]
      remark #15388: vectorization support: reference mwjfnums0t0 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfnums0t2 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfnums1t0 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfdens0t0 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference mwjfdens0t1 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference mwjfdens0t3 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference rhoout has aligned access   [ state_test_offload.F90(244,11) ]
      remark #15388: vectorization support: reference drhods has aligned access   [ state_test_offload.F90(273,10) ]
      remark #15388: vectorization support: reference mwjfnums1t0 has aligned access   [ state_test_offload.F90(273,10) ]
      remark #15412: vectorization support: streaming store was generated for rhoout   [ state_test_offload.F90(244,11) ]
      remark #15412: vectorization support: streaming store was generated for drhods   [ state_test_offload.F90(273,10) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15467: unmasked aligned streaming stores: 2 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 250 
      remark #15477: vector loop cost: 37.000 
      remark #15478: estimated potential speedup: 6.750 
      remark #15479: lightweight vector operations: 140 
      remark #15488: --- end vector loop cost summary ---
      remark #25018: Total number of lines prefetched=16
      remark #25019: Number of spatial prefetches=16, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(225,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(227,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,61) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(233,42) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(236,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(236,41) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(237,18) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END

   LOOP BEGIN at state_test_offload.F90(223,7)
   <Predicate Optimized v16>
      remark #15388: vectorization support: reference tempk has aligned access   [ state_test_offload.F90(226,7) ]
      remark #15388: vectorization support: reference saltk has aligned access   [ state_test_offload.F90(229,7) ]
      remark #15388: vectorization support: reference mwjfnums0t0 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfnums0t2 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfnums1t0 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfdens0t0 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference mwjfdens0t1 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference mwjfdens0t3 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference rhoout has aligned access   [ state_test_offload.F90(244,11) ]
      remark #15412: vectorization support: streaming store was generated for rhoout   [ state_test_offload.F90(244,11) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15467: unmasked aligned streaming stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 194 
      remark #15477: vector loop cost: 26.750 
      remark #15478: estimated potential speedup: 7.240 
      remark #15479: lightweight vector operations: 97 
      remark #15488: --- end vector loop cost summary ---
      remark #25018: Total number of lines prefetched=16
      remark #25019: Number of spatial prefetches=16, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(225,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(227,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,61) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(233,42) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(236,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(236,41) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(237,18) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END

   LOOP BEGIN at state_test_offload.F90(223,7)
   <Predicate Optimized v2>
      remark #15388: vectorization support: reference tempk has aligned access   [ state_test_offload.F90(226,7) ]
      remark #15388: vectorization support: reference saltk has aligned access   [ state_test_offload.F90(229,7) ]
      remark #15388: vectorization support: reference mwjfnums0t0 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfnums0t2 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfnums1t0 has aligned access   [ state_test_offload.F90(232,7) ]
      remark #15388: vectorization support: reference mwjfdens0t0 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference mwjfdens0t1 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference mwjfdens0t3 has aligned access   [ state_test_offload.F90(241,7) ]
      remark #15388: vectorization support: reference rhofull has aligned access   [ state_test_offload.F90(248,11) ]
      remark #15388: vectorization support: reference drhodt has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15388: vectorization support: reference mwjfnums0t2 has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15388: vectorization support: reference mwjfdens0t1 has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15388: vectorization support: reference mwjfdens0t3 has aligned access   [ state_test_offload.F90(262,11) ]
      remark #15388: vectorization support: reference drhods has aligned access   [ state_test_offload.F90(273,10) ]
      remark #15388: vectorization support: reference mwjfnums1t0 has aligned access   [ state_test_offload.F90(273,10) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 394 
      remark #15477: vector loop cost: 50.250 
      remark #15478: estimated potential speedup: 7.830 
      remark #15479: lightweight vector operations: 198 
      remark #15488: --- end vector loop cost summary ---
      remark #25018: Total number of lines prefetched=22
      remark #25019: Number of spatial prefetches=22, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(225,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(227,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,61) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(233,42) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(236,16) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(236,41) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(237,18) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(248,11) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(262,11) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(273,10) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END
LOOP END


Non-optimizable loops:


LOOP BEGIN at state_test_offload.F90(219,7)
   remark #15543: loop was not vectorized: loop with function call not considered an optimization candidate.   [ state_test_offload.F90(218,7) ]
LOOP END

    Report from: Code generation optimizations [cg]

state_test_offload.F90(194,1):remark #34026: call to memcpy implemented as a call to optimized library version
state_test_offload.F90(194,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (64, 0), and destination (alignment, offset): (64, 0)
===========================================================================

    Report from: Interprocedural optimizations [ipo]

INLINING FOOTNOTES:

<1> Inlining the subprogram will lead to incorrect program behavior.

