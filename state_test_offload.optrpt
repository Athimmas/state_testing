
    Report from: Interprocedural optimizations [ipo]

  WHOLE PROGRAM (SAFE) [EITHER METHOD]: false
  WHOLE PROGRAM (SEEN) [TABLE METHOD]: false
  WHOLE PROGRAM (READ) [OBJECT READER METHOD]: false

INLINING OPTION VALUES:
  -inline-factor: 100
  -inline-min-size: 30
  -inline-max-size: 230
  -inline-max-total-size: 2000
  -inline-max-per-routine: 10000
  -inline-max-per-compile: 500000

In the inlining report below:
   "sz" refers to the "size" of the routine. The smaller a routine's size,
      the more likely it is to be inlined.
   "isz" refers to the "inlined size" of the routine. This is the amount
      the calling routine will grow if the called routine is inlined into it.
      The compiler generally limits the amount a routine can grow by having
      routines inlined into it.

Begin optimization report for: STATE_DUMMY

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (STATE_DUMMY) [1/2=50.0%] state_test_offload.F90(1,9)
  -> EXTERN: (1,9) for_set_reentrancy
  -> EXTERN: (23,12) for_random_number
  -> EXTERN: (24,12) for_random_number
  -> EXTERN: (25,12) for_random_number
  -> EXTERN: (26,12) for_random_number
  -> (28,12) STATE_DUMMY:STATE (isz = 1112) (sz = 1133)
     [[ Unable to inline callsite  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at state_test_offload.F90(23,12)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(23,12)
      remark #15388: vectorization support: reference tmix has aligned access
      remark #15300: LOOP WAS VECTORIZED
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 104 
      remark #15477: vector loop cost: 38.000 
      remark #15478: estimated potential speedup: 2.730 
      remark #15479: lightweight vector operations: 4 
      remark #15480: medium-overhead vector operations: 1 
      remark #15481: heavy-overhead vector operations: 1 
      remark #15482: vectorized math library calls: 1 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=1440
   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(24,12)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(24,12)
      remark #15388: vectorization support: reference temp1 has aligned access
      remark #15300: LOOP WAS VECTORIZED
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 104 
      remark #15477: vector loop cost: 38.000 
      remark #15478: estimated potential speedup: 2.730 
      remark #15479: lightweight vector operations: 4 
      remark #15480: medium-overhead vector operations: 1 
      remark #15481: heavy-overhead vector operations: 1 
      remark #15482: vectorized math library calls: 1 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=1440
   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(25,12)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(25,12)
      remark #15388: vectorization support: reference temp2 has aligned access
      remark #15300: LOOP WAS VECTORIZED
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 104 
      remark #15477: vector loop cost: 38.000 
      remark #15478: estimated potential speedup: 2.730 
      remark #15479: lightweight vector operations: 4 
      remark #15480: medium-overhead vector operations: 1 
      remark #15481: heavy-overhead vector operations: 1 
      remark #15482: vectorized math library calls: 1 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=1440
   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(26,12)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(26,12)
      remark #15388: vectorization support: reference temp3 has aligned access
      remark #15300: LOOP WAS VECTORIZED
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 104 
      remark #15477: vector loop cost: 38.000 
      remark #15478: estimated potential speedup: 2.730 
      remark #15479: lightweight vector operations: 4 
      remark #15480: medium-overhead vector operations: 1 
      remark #15481: heavy-overhead vector operations: 1 
      remark #15482: vectorized math library calls: 1 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=1440
   LOOP END
LOOP END
===========================================================================

Begin optimization report for: STATE_DUMMY:STATE

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (STATE_DUMMY:STATE) [2/2=100.0%] state_test_offload.F90(33,12)
  -> EXTERN: (123,12) for_random_number
  -> EXTERN: (124,12) for_random_number
  -> EXTERN: (142,36) __powr8i4
  -> EXTERN: (154,12) omp_set_num_threads
  -> EXTERN: (156,20) omp_get_wtime
  -> EXTERN: (204,18) omp_get_wtime
  -> EXTERN: (279,18) omp_get_wtime
  -> EXTERN: (283,7) for_write_seq_lis_xmit
  -> EXTERN: (283,7) for_write_seq_lis
  -> EXTERN: (284,7) for_write_seq_lis_xmit
  -> EXTERN: (284,7) for_write_seq_lis
  -> EXTERN: (286,7) for_write_seq_lis
  -> EXTERN: (287,7) for_write_seq_lis
  -> EXTERN: (288,7) for_write_seq_lis
  -> EXTERN: (289,7) for_write_seq_lis
  -> EXTERN: (290,7) for_write_seq_lis
  -> EXTERN: (291,7) for_write_seq_lis
  -> EXTERN: (292,7) for_write_seq_lis
  -> EXTERN: (293,7) for_write_seq_lis
  -> EXTERN: (294,7) for_write_seq_lis


    Report from: OpenMP optimizations [openmp]

OpenMP Construct at state_test_offload.F90(165,7)
   remark #16201: OpenMP DEFINED REGION WAS PARALLELIZED
OpenMP Construct at state_test_offload.F90(213,7)
   remark #16201: OpenMP DEFINED REGION WAS PARALLELIZED

    Report from: Offload optimizations [offload]

OFFLOAD:state(152,1):  Offload to target MIC <expr>
 Evaluate length/align/alloc_if/free_if/alloc/into expressions
 Data sent from host to target
       first_time, scalar size 8 bytes
       saltk, pointer to data with element count specified in pragma
       rhoout, pointer to data with element count specified in pragma
       rhofull, pointer to data with element count specified in pragma
       drhodt, pointer to data with element count specified in pragma
       drhods, pointer to data with element count specified in pragma
       tempk, pointer to data with element count specified in pragma
       __offload_stack_ptr_state$TQ$_8_V$5c.0, pointer to array reference expression with base
       __offload_stack_ptr_state$SQ$_8_V$5b.0, pointer to array reference expression with base
       __offload_stack_ptr_state$WORK1$_8_V$58.0, pointer to array reference expression with base
       __offload_stack_ptr_state$WORK2$_8_V$57.0, pointer to array reference expression with base
       __offload_stack_ptr_state$WORK3$_8_V$56.0, pointer to array reference expression with base
       __offload_stack_ptr_state$WORK4$_8_V$55.0, pointer to array reference expression with base
       __offload_stack_ptr_state$SQR$_8_V$5a.0, pointer to array reference expression with base
       __offload_stack_ptr_state$DENOMK$_8_V$59.0, pointer to array reference expression with base
       __offload_stack_ptr_state$TMAX$_8_V$4e.0, pointer to array reference expression with base
       __offload_stack_ptr_state$TMIN$_8_V$4f.0, pointer to array reference expression with base
       __offload_stack_ptr_state$SMAX$_8_V$4c.0, pointer to array reference expression with base
       __offload_stack_ptr_state$SMIN$_8_V$4d.0, pointer to array reference expression with base
       kk, pointer to data with element count specified in pragma
       mwjfnums0t0, scalar size 8 bytes
       mwjfnums0t1, scalar size 8 bytes
       mwjfnums0t2, scalar size 8 bytes
       mwjfnums0t3, scalar size 8 bytes
       mwjfnums1t0, scalar size 8 bytes
       mwjfnums1t1, scalar size 8 bytes
       mwjfnums2t0, scalar size 8 bytes
       mwjfdens0t0, scalar size 8 bytes
       mwjfdens0t1, scalar size 8 bytes
       mwjfdens0t2, scalar size 8 bytes
       mwjfdens0t3, scalar size 8 bytes
       mwjfdens0t4, scalar size 8 bytes
       mwjfdens1t0, scalar size 8 bytes
       mwjfdens1t1, scalar size 8 bytes
       mwjfdens1t3, scalar size 8 bytes
       mwjfdensqt0, scalar size 8 bytes
       mwjfdensqt2, scalar size 8 bytes
       twork1, scalar size 8 bytes
       twork2, scalar size 8 bytes
       twork3, scalar size 8 bytes
       twork4, scalar size 8 bytes
       j, scalar size 4 bytes
       i, scalar size 4 bytes
       start_time, scalar size 8 bytes
       tdenomk, scalar size 8 bytes
       end_time, scalar size 8 bytes
 Data received by host from target
       first_time, scalar size 8 bytes
       rhoout, pointer to data with element count specified in pragma
       rhofull, pointer to data with element count specified in pragma
       drhodt, pointer to data with element count specified in pragma
       drhods, pointer to data with element count specified in pragma
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       mwjfnums0t0, scalar size 8 bytes
       mwjfnums0t1, scalar size 8 bytes
       mwjfnums0t2, scalar size 8 bytes
       mwjfnums0t3, scalar size 8 bytes
       mwjfnums1t0, scalar size 8 bytes
       mwjfnums1t1, scalar size 8 bytes
       mwjfnums2t0, scalar size 8 bytes
       mwjfdens0t0, scalar size 8 bytes
       mwjfdens0t1, scalar size 8 bytes
       mwjfdens0t2, scalar size 8 bytes
       mwjfdens0t3, scalar size 8 bytes
       mwjfdens0t4, scalar size 8 bytes
       mwjfdens1t0, scalar size 8 bytes
       mwjfdens1t1, scalar size 8 bytes
       mwjfdens1t3, scalar size 8 bytes
       mwjfdensqt0, scalar size 8 bytes
       mwjfdensqt2, scalar size 8 bytes
       twork1, scalar size 8 bytes
       twork2, scalar size 8 bytes
       twork3, scalar size 8 bytes
       twork4, scalar size 8 bytes
       j, scalar size 4 bytes
       i, scalar size 4 bytes
       start_time, scalar size 8 bytes
       tdenomk, scalar size 8 bytes
       end_time, scalar size 8 bytes


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at state_test_offload.F90(117,7)
   remark #15388: vectorization support: reference tmin has aligned access
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 4 
   remark #15477: vector loop cost: 3.000 
   remark #15478: estimated potential speedup: 2.660 
   remark #15479: lightweight vector operations: 2 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=15
LOOP END

LOOP BEGIN at state_test_offload.F90(118,7)
   remark #15388: vectorization support: reference tmax has aligned access
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 4 
   remark #15477: vector loop cost: 3.000 
   remark #15478: estimated potential speedup: 2.660 
   remark #15479: lightweight vector operations: 2 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=15
LOOP END

LOOP BEGIN at state_test_offload.F90(119,7)
   remark #25408: memset generated
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy
LOOP END

LOOP BEGIN at state_test_offload.F90(120,7)
   remark #15388: vectorization support: reference smax has aligned access
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 4 
   remark #15477: vector loop cost: 3.000 
   remark #15478: estimated potential speedup: 2.660 
   remark #15479: lightweight vector operations: 2 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=15
LOOP END

LOOP BEGIN at state_test_offload.F90(123,12)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(123,12)
      remark #15388: vectorization support: reference _8.0.2_ptr.var has aligned access
      remark #15300: LOOP WAS VECTORIZED
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 104 
      remark #15477: vector loop cost: 38.000 
      remark #15478: estimated potential speedup: 2.730 
      remark #15479: lightweight vector operations: 4 
      remark #15480: medium-overhead vector operations: 1 
      remark #15481: heavy-overhead vector operations: 1 
      remark #15482: vectorized math library calls: 1 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=1440
   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(124,12)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(124,12)
      remark #15388: vectorization support: reference _8.0.2_ptr.var has aligned access
      remark #15300: LOOP WAS VECTORIZED
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 104 
      remark #15477: vector loop cost: 38.000 
      remark #15478: estimated potential speedup: 2.730 
      remark #15479: lightweight vector operations: 4 
      remark #15480: medium-overhead vector operations: 1 
      remark #15481: heavy-overhead vector operations: 1 
      remark #15482: vectorized math library calls: 1 
      remark #15488: --- end vector loop cost summary ---
      remark #25015: Estimate of max trip count of loop=1440
   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(286,16)
   remark #25420: Collapsed with loop at line 286 
   remark #15388: vectorization support: reference _8.0.2_ptr.var has aligned access
   remark #15399: vectorization support: unroll factor set to 8
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 6 
   remark #15477: vector loop cost: 20.000 
   remark #15478: estimated potential speedup: 2.390 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=471420

   LOOP BEGIN at state_test_offload.F90(286,16)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(287,16)
   remark #25420: Collapsed with loop at line 287 
   remark #15388: vectorization support: reference _8.0.2_ptr.var has aligned access
   remark #15399: vectorization support: unroll factor set to 8
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 6 
   remark #15477: vector loop cost: 20.000 
   remark #15478: estimated potential speedup: 2.390 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=471420

   LOOP BEGIN at state_test_offload.F90(287,16)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(288,16)
   remark #25420: Collapsed with loop at line 288 
   remark #15388: vectorization support: reference _8.0.2_ptr.var has aligned access
   remark #15399: vectorization support: unroll factor set to 8
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 6 
   remark #15477: vector loop cost: 20.000 
   remark #15478: estimated potential speedup: 2.390 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=471420

   LOOP BEGIN at state_test_offload.F90(288,16)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(289,16)
   remark #25420: Collapsed with loop at line 289 
   remark #15388: vectorization support: reference _8.0.2_ptr.var has aligned access
   remark #15399: vectorization support: unroll factor set to 8
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 6 
   remark #15477: vector loop cost: 20.000 
   remark #15478: estimated potential speedup: 2.390 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=471420

   LOOP BEGIN at state_test_offload.F90(289,16)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(290,16)
<Peeled>
LOOP END

LOOP BEGIN at state_test_offload.F90(290,16)
   remark #25420: Collapsed with loop at line 290 
   remark #15388: vectorization support: reference drhods has aligned access
   remark #15399: vectorization support: unroll factor set to 8
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 6 
   remark #15477: vector loop cost: 20.000 
   remark #15478: estimated potential speedup: 2.390 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=471420

   LOOP BEGIN at state_test_offload.F90(290,16)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(290,16)
<Remainder>
   remark #15388: vectorization support: reference drhods has aligned access
   remark #15301: REMAINDER LOOP WAS VECTORIZED
LOOP END

LOOP BEGIN at state_test_offload.F90(290,16)
<Remainder>
LOOP END

LOOP BEGIN at state_test_offload.F90(291,16)
<Peeled>
LOOP END

LOOP BEGIN at state_test_offload.F90(291,16)
   remark #25420: Collapsed with loop at line 291 
   remark #15388: vectorization support: reference drhodt has aligned access
   remark #15399: vectorization support: unroll factor set to 8
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 6 
   remark #15477: vector loop cost: 20.000 
   remark #15478: estimated potential speedup: 2.390 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=471420

   LOOP BEGIN at state_test_offload.F90(291,16)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(291,16)
<Remainder>
   remark #15388: vectorization support: reference drhodt has aligned access
   remark #15301: REMAINDER LOOP WAS VECTORIZED
LOOP END

LOOP BEGIN at state_test_offload.F90(291,16)
<Remainder>
LOOP END

LOOP BEGIN at state_test_offload.F90(292,16)
<Peeled>
LOOP END

LOOP BEGIN at state_test_offload.F90(292,16)
   remark #25420: Collapsed with loop at line 292 
   remark #15388: vectorization support: reference rhoout has aligned access
   remark #15399: vectorization support: unroll factor set to 8
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 6 
   remark #15477: vector loop cost: 20.000 
   remark #15478: estimated potential speedup: 2.390 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=471420

   LOOP BEGIN at state_test_offload.F90(292,16)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(292,16)
<Remainder>
   remark #15388: vectorization support: reference rhoout has aligned access
   remark #15301: REMAINDER LOOP WAS VECTORIZED
LOOP END

LOOP BEGIN at state_test_offload.F90(292,16)
<Remainder>
LOOP END

LOOP BEGIN at state_test_offload.F90(293,16)
<Peeled>
LOOP END

LOOP BEGIN at state_test_offload.F90(293,16)
   remark #25420: Collapsed with loop at line 293 
   remark #15388: vectorization support: reference rhofull has aligned access
   remark #15399: vectorization support: unroll factor set to 8
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 6 
   remark #15477: vector loop cost: 20.000 
   remark #15478: estimated potential speedup: 2.390 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=471420

   LOOP BEGIN at state_test_offload.F90(293,16)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(293,16)
<Remainder>
   remark #15388: vectorization support: reference rhofull has aligned access
   remark #15301: REMAINDER LOOP WAS VECTORIZED
LOOP END

LOOP BEGIN at state_test_offload.F90(293,16)
<Remainder>
LOOP END

LOOP BEGIN at state_test_offload.F90(294,16)
   remark #25420: Collapsed with loop at line 294 
   remark #15388: vectorization support: reference _8.0.2_ptr.var has aligned access
   remark #15399: vectorization support: unroll factor set to 8
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 6 
   remark #15477: vector loop cost: 20.000 
   remark #15478: estimated potential speedup: 2.390 
   remark #15479: lightweight vector operations: 4 
   remark #15480: medium-overhead vector operations: 1 
   remark #15488: --- end vector loop cost summary ---
   remark #25015: Estimate of max trip count of loop=471420

   LOOP BEGIN at state_test_offload.F90(294,16)
      remark #25421: Loop eliminated in Collapsing 

   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

state_test_offload.F90(119,7):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (64, 0)
state_test_offload.F90(152,1):remark #34026: call to memcpy implemented as a call to optimized library version
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
===========================================================================

    Report from: Interprocedural optimizations [ipo]

INLINING FOOTNOTES:

<1> Inlining the subprogram will lead to incorrect program behavior.


    Report from: Interprocedural optimizations [ipo]

  WHOLE PROGRAM (SAFE) [EITHER METHOD]: false
  WHOLE PROGRAM (SEEN) [TABLE METHOD]: false
  WHOLE PROGRAM (READ) [OBJECT READER METHOD]: false

INLINING OPTION VALUES:
  -inline-factor: 100
  -inline-min-size: 30
  -inline-max-size: 230
  -inline-max-total-size: 2000
  -inline-max-per-routine: 10000
  -inline-max-per-compile: 500000

In the inlining report below:
   "sz" refers to the "size" of the routine. The smaller a routine's size,
      the more likely it is to be inlined.
   "isz" refers to the "inlined size" of the routine. This is the amount
      the calling routine will grow if the called routine is inlined into it.
      The compiler generally limits the amount a routine can grow by having
      routines inlined into it.

*MIC* Begin optimization report for: STATE_DUMMY

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (STATE_DUMMY) [1/2=50.0%] state_test_offload.F90(1,9)
  -> EXTERN: (1,9) for_set_reentrancy
  -> EXTERN: (23,12) for_random_number
  -> EXTERN: (24,12) for_random_number
  -> EXTERN: (25,12) for_random_number
  -> EXTERN: (26,12) for_random_number
  -> (28,12) STATE_DUMMY:STATE (isz = 1112) (sz = 1133)
     [[ Unable to inline callsite  <1>]]

===========================================================================

*MIC* Begin optimization report for: STATE_DUMMY:STATE

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (STATE_DUMMY:STATE) [2/2=100.0%] state_test_offload.F90(33,12)
  -> EXTERN: (123,12) for_random_number
  -> EXTERN: (124,12) for_random_number
  -> EXTERN: (142,36) __powr8i4
  -> EXTERN: (154,12) omp_set_num_threads
  -> EXTERN: (156,20) omp_get_wtime
  -> EXTERN: (204,18) omp_get_wtime
  -> EXTERN: (279,18) omp_get_wtime
  -> EXTERN: (283,7) for_write_seq_lis_xmit
  -> EXTERN: (283,7) for_write_seq_lis
  -> EXTERN: (284,7) for_write_seq_lis_xmit
  -> EXTERN: (284,7) for_write_seq_lis
  -> EXTERN: (286,7) for_write_seq_lis
  -> EXTERN: (287,7) for_write_seq_lis
  -> EXTERN: (288,7) for_write_seq_lis
  -> EXTERN: (289,7) for_write_seq_lis
  -> EXTERN: (290,7) for_write_seq_lis
  -> EXTERN: (291,7) for_write_seq_lis
  -> EXTERN: (292,7) for_write_seq_lis
  -> EXTERN: (293,7) for_write_seq_lis
  -> EXTERN: (294,7) for_write_seq_lis


    Report from: OpenMP optimizations [openmp]

OpenMP Construct at state_test_offload.F90(165,7)
   remark #16201: OpenMP DEFINED REGION WAS PARALLELIZED
OpenMP Construct at state_test_offload.F90(213,7)
   remark #16201: OpenMP DEFINED REGION WAS PARALLELIZED

    Report from: Offload optimizations [offload]

OFFLOAD:state_dummy_IP_state_(152,1):  Outlined offload region
 Data received by target from host
       first_time, scalar size 8 bytes
       saltk, pointer to data with element count specified in pragma
       rhoout, pointer to data with element count specified in pragma
       rhofull, pointer to data with element count specified in pragma
       drhodt, pointer to data with element count specified in pragma
       drhods, pointer to data with element count specified in pragma
       tempk, pointer to data with element count specified in pragma
       __offload_stack_ptr_state$TQ$_8_V$5c.0, pointer to array reference expression with base
       __offload_stack_ptr_state$SQ$_8_V$5b.0, pointer to array reference expression with base
       __offload_stack_ptr_state$WORK1$_8_V$58.0, pointer to array reference expression with base
       __offload_stack_ptr_state$WORK2$_8_V$57.0, pointer to array reference expression with base
       __offload_stack_ptr_state$WORK3$_8_V$56.0, pointer to array reference expression with base
       __offload_stack_ptr_state$WORK4$_8_V$55.0, pointer to array reference expression with base
       __offload_stack_ptr_state$SQR$_8_V$5a.0, pointer to array reference expression with base
       __offload_stack_ptr_state$DENOMK$_8_V$59.0, pointer to array reference expression with base
       __offload_stack_ptr_state$TMAX$_8_V$4e.0, pointer to array reference expression with base
       __offload_stack_ptr_state$TMIN$_8_V$4f.0, pointer to array reference expression with base
       __offload_stack_ptr_state$SMAX$_8_V$4c.0, pointer to array reference expression with base
       __offload_stack_ptr_state$SMIN$_8_V$4d.0, pointer to array reference expression with base
       kk, pointer to data with element count specified in pragma
       mwjfnums0t0, scalar size 8 bytes
       mwjfnums0t1, scalar size 8 bytes
       mwjfnums0t2, scalar size 8 bytes
       mwjfnums0t3, scalar size 8 bytes
       mwjfnums1t0, scalar size 8 bytes
       mwjfnums1t1, scalar size 8 bytes
       mwjfnums2t0, scalar size 8 bytes
       mwjfdens0t0, scalar size 8 bytes
       mwjfdens0t1, scalar size 8 bytes
       mwjfdens0t2, scalar size 8 bytes
       mwjfdens0t3, scalar size 8 bytes
       mwjfdens0t4, scalar size 8 bytes
       mwjfdens1t0, scalar size 8 bytes
       mwjfdens1t1, scalar size 8 bytes
       mwjfdens1t3, scalar size 8 bytes
       mwjfdensqt0, scalar size 8 bytes
       mwjfdensqt2, scalar size 8 bytes
       twork1, scalar size 8 bytes
       twork2, scalar size 8 bytes
       twork3, scalar size 8 bytes
       twork4, scalar size 8 bytes
       j, scalar size 4 bytes
       i, scalar size 4 bytes
       start_time, scalar size 8 bytes
       tdenomk, scalar size 8 bytes
       end_time, scalar size 8 bytes
 Data sent from target to host
       first_time, scalar size 8 bytes
       rhoout, pointer to data with element count specified in pragma
       rhofull, pointer to data with element count specified in pragma
       drhodt, pointer to data with element count specified in pragma
       drhods, pointer to data with element count specified in pragma
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       __offload_stack_ptr_state_dummy_IP_state_.44, pointer to array reference expression with base
       mwjfnums0t0, scalar size 8 bytes
       mwjfnums0t1, scalar size 8 bytes
       mwjfnums0t2, scalar size 8 bytes
       mwjfnums0t3, scalar size 8 bytes
       mwjfnums1t0, scalar size 8 bytes
       mwjfnums1t1, scalar size 8 bytes
       mwjfnums2t0, scalar size 8 bytes
       mwjfdens0t0, scalar size 8 bytes
       mwjfdens0t1, scalar size 8 bytes
       mwjfdens0t2, scalar size 8 bytes
       mwjfdens0t3, scalar size 8 bytes
       mwjfdens0t4, scalar size 8 bytes
       mwjfdens1t0, scalar size 8 bytes
       mwjfdens1t1, scalar size 8 bytes
       mwjfdens1t3, scalar size 8 bytes
       mwjfdensqt0, scalar size 8 bytes
       mwjfdensqt2, scalar size 8 bytes
       twork1, scalar size 8 bytes
       twork2, scalar size 8 bytes
       twork3, scalar size 8 bytes
       twork4, scalar size 8 bytes
       j, scalar size 4 bytes
       i, scalar size 4 bytes
       start_time, scalar size 8 bytes
       tdenomk, scalar size 8 bytes
       end_time, scalar size 8 bytes


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at state_test_offload.F90(176,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(180,7)
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(182,7) ]
      remark #15388: vectorization support: reference tempk has aligned access   [ state_test_offload.F90(182,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(183,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(183,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(184,7) ]
      remark #15388: vectorization support: reference saltk has aligned access   [ state_test_offload.F90(184,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(185,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(185,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(186,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(186,7) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(187,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(187,7) ]
      remark #15388: vectorization support: reference rhoout has aligned access   [ state_test_offload.F90(194,7) ]
      remark #15388: vectorization support: reference drhodt has aligned access   [ state_test_offload.F90(195,7) ]
      remark #15388: vectorization support: reference rhofull has aligned access   [ state_test_offload.F90(196,7) ]
      remark #15388: vectorization support: reference drhods has aligned access   [ state_test_offload.F90(197,7) ]
      remark #15412: vectorization support: streaming store was generated for tq   [ state_test_offload.F90(182,7) ]
      remark #15412: vectorization support: streaming store was generated for tq   [ state_test_offload.F90(183,7) ]
      remark #15412: vectorization support: streaming store was generated for sq   [ state_test_offload.F90(184,7) ]
      remark #15412: vectorization support: streaming store was generated for sq   [ state_test_offload.F90(185,7) ]
      remark #15412: vectorization support: streaming store was generated for sq   [ state_test_offload.F90(186,7) ]
      remark #15412: vectorization support: streaming store was generated for sqr   [ state_test_offload.F90(187,7) ]
      remark #15412: vectorization support: streaming store was generated for rhoout   [ state_test_offload.F90(194,7) ]
      remark #15412: vectorization support: streaming store was generated for drhodt   [ state_test_offload.F90(195,7) ]
      remark #15412: vectorization support: streaming store was generated for rhofull   [ state_test_offload.F90(196,7) ]
      remark #15412: vectorization support: streaming store was generated for drhods   [ state_test_offload.F90(197,7) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15467: unmasked aligned streaming stores: 10 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 101 
      remark #15477: vector loop cost: 9.250 
      remark #15478: estimated potential speedup: 10.910 
      remark #15479: lightweight vector operations: 41 
      remark #15488: --- end vector loop cost summary ---
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 5
      remark #25018: Total number of lines prefetched=4
      remark #25019: Number of spatial prefetches=4, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(182,21) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(184,21) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END
LOOP END

LOOP BEGIN at state_test_offload.F90(224,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at state_test_offload.F90(228,7)
   <Predicate Optimized v7>
      remark #25422: Invariant Condition at line 242 hoisted out of this loop
      remark #25422: Invariant Condition at line 246 hoisted out of this loop
      remark #25422: Invariant Condition at line 250 hoisted out of this loop
      remark #25422: Invariant Condition at line 264 hoisted out of this loop
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference rhoout has aligned access   [ state_test_offload.F90(243,11) ]
      remark #15388: vectorization support: reference rhofull has aligned access   [ state_test_offload.F90(247,11) ]
      remark #15388: vectorization support: reference drhodt has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference drhods has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15412: vectorization support: streaming store was generated for rhoout   [ state_test_offload.F90(243,11) ]
      remark #15412: vectorization support: streaming store was generated for rhofull   [ state_test_offload.F90(247,11) ]
      remark #15412: vectorization support: streaming store was generated for drhodt   [ state_test_offload.F90(261,11) ]
      remark #15412: vectorization support: streaming store was generated for drhods   [ state_test_offload.F90(272,10) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15467: unmasked aligned streaming stores: 4 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 258 
      remark #15477: vector loop cost: 43.620 
      remark #15478: estimated potential speedup: 5.910 
      remark #15479: lightweight vector operations: 178 
      remark #15488: --- end vector loop cost summary ---
      remark #25018: Total number of lines prefetched=6
      remark #25019: Number of spatial prefetches=6, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(231,30) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,41) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(238,12) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END

   LOOP BEGIN at state_test_offload.F90(228,7)
   <Predicate Optimized v8>
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference rhoout has aligned access   [ state_test_offload.F90(243,11) ]
      remark #15388: vectorization support: reference rhofull has aligned access   [ state_test_offload.F90(247,11) ]
      remark #15388: vectorization support: reference drhodt has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15412: vectorization support: streaming store was generated for rhoout   [ state_test_offload.F90(243,11) ]
      remark #15412: vectorization support: streaming store was generated for rhofull   [ state_test_offload.F90(247,11) ]
      remark #15412: vectorization support: streaming store was generated for drhodt   [ state_test_offload.F90(261,11) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15467: unmasked aligned streaming stores: 3 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 201 
      remark #15477: vector loop cost: 33.370 
      remark #15478: estimated potential speedup: 6.020 
      remark #15479: lightweight vector operations: 135 
      remark #15488: --- end vector loop cost summary ---
      remark #25018: Total number of lines prefetched=6
      remark #25019: Number of spatial prefetches=6, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(231,30) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,41) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(238,12) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END

   LOOP BEGIN at state_test_offload.F90(228,7)
   <Predicate Optimized v9>
      remark #25422: Invariant Condition at line 264 hoisted out of this loop
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference rhoout has aligned access   [ state_test_offload.F90(243,11) ]
      remark #15388: vectorization support: reference rhofull has aligned access   [ state_test_offload.F90(247,11) ]
      remark #15388: vectorization support: reference drhods has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15412: vectorization support: streaming store was generated for rhoout   [ state_test_offload.F90(243,11) ]
      remark #15412: vectorization support: streaming store was generated for rhofull   [ state_test_offload.F90(247,11) ]
      remark #15412: vectorization support: streaming store was generated for drhods   [ state_test_offload.F90(272,10) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15467: unmasked aligned streaming stores: 3 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 183 
      remark #15477: vector loop cost: 31.370 
      remark #15478: estimated potential speedup: 5.830 
      remark #15479: lightweight vector operations: 125 
      remark #15488: --- end vector loop cost summary ---
      remark #25018: Total number of lines prefetched=6
      remark #25019: Number of spatial prefetches=6, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(231,30) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,41) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(238,12) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END

   LOOP BEGIN at state_test_offload.F90(228,7)
   <Predicate Optimized v10>
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference rhoout has aligned access   [ state_test_offload.F90(243,11) ]
      remark #15388: vectorization support: reference rhofull has aligned access   [ state_test_offload.F90(247,11) ]
      remark #15412: vectorization support: streaming store was generated for rhoout   [ state_test_offload.F90(243,11) ]
      remark #15412: vectorization support: streaming store was generated for rhofull   [ state_test_offload.F90(247,11) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15467: unmasked aligned streaming stores: 2 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 127 
      remark #15477: vector loop cost: 21.120 
      remark #15478: estimated potential speedup: 6.000 
      remark #15479: lightweight vector operations: 82 
      remark #15488: --- end vector loop cost summary ---
      remark #25018: Total number of lines prefetched=6
      remark #25019: Number of spatial prefetches=6, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(231,30) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,41) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(238,12) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END

   LOOP BEGIN at state_test_offload.F90(228,7)
   <Predicate Optimized v13>
      remark #25422: Invariant Condition at line 250 hoisted out of this loop
      remark #25422: Invariant Condition at line 264 hoisted out of this loop
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference rhoout has aligned access   [ state_test_offload.F90(243,11) ]
      remark #15388: vectorization support: reference drhodt has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference drhods has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15412: vectorization support: streaming store was generated for rhoout   [ state_test_offload.F90(243,11) ]
      remark #15412: vectorization support: streaming store was generated for drhodt   [ state_test_offload.F90(261,11) ]
      remark #15412: vectorization support: streaming store was generated for drhods   [ state_test_offload.F90(272,10) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15467: unmasked aligned streaming stores: 3 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 252 
      remark #15477: vector loop cost: 42.620 
      remark #15478: estimated potential speedup: 5.900 
      remark #15479: lightweight vector operations: 173 
      remark #15488: --- end vector loop cost summary ---
      remark #25018: Total number of lines prefetched=6
      remark #25019: Number of spatial prefetches=6, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(231,30) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,41) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(238,12) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END

   LOOP BEGIN at state_test_offload.F90(228,7)
   <Predicate Optimized v14>
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference rhoout has aligned access   [ state_test_offload.F90(243,11) ]
      remark #15388: vectorization support: reference drhodt has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15412: vectorization support: streaming store was generated for rhoout   [ state_test_offload.F90(243,11) ]
      remark #15412: vectorization support: streaming store was generated for drhodt   [ state_test_offload.F90(261,11) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15467: unmasked aligned streaming stores: 2 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 195 
      remark #15477: vector loop cost: 32.370 
      remark #15478: estimated potential speedup: 6.020 
      remark #15479: lightweight vector operations: 130 
      remark #15488: --- end vector loop cost summary ---
      remark #25018: Total number of lines prefetched=6
      remark #25019: Number of spatial prefetches=6, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(231,30) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,41) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(238,12) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END

   LOOP BEGIN at state_test_offload.F90(228,7)
   <Predicate Optimized v15>
      remark #25422: Invariant Condition at line 264 hoisted out of this loop
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference rhoout has aligned access   [ state_test_offload.F90(243,11) ]
      remark #15388: vectorization support: reference drhods has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15412: vectorization support: streaming store was generated for rhoout   [ state_test_offload.F90(243,11) ]
      remark #15412: vectorization support: streaming store was generated for drhods   [ state_test_offload.F90(272,10) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15467: unmasked aligned streaming stores: 2 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 177 
      remark #15477: vector loop cost: 30.370 
      remark #15478: estimated potential speedup: 5.820 
      remark #15479: lightweight vector operations: 120 
      remark #15488: --- end vector loop cost summary ---
      remark #25018: Total number of lines prefetched=6
      remark #25019: Number of spatial prefetches=6, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(231,30) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,41) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(238,12) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END

   LOOP BEGIN at state_test_offload.F90(228,7)
   <Predicate Optimized v16>
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference rhoout has aligned access   [ state_test_offload.F90(243,11) ]
      remark #15412: vectorization support: streaming store was generated for rhoout   [ state_test_offload.F90(243,11) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15467: unmasked aligned streaming stores: 1 
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 120 
      remark #15477: vector loop cost: 20.120 
      remark #15478: estimated potential speedup: 5.960 
      remark #15479: lightweight vector operations: 77 
      remark #15488: --- end vector loop cost summary ---
      remark #25018: Total number of lines prefetched=6
      remark #25019: Number of spatial prefetches=6, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(231,30) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,41) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(238,12) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END

   LOOP BEGIN at state_test_offload.F90(228,7)
   <Predicate Optimized v2>
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(231,7) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(240,11) ]
      remark #15388: vectorization support: reference rhofull has aligned access   [ state_test_offload.F90(247,11) ]
      remark #15388: vectorization support: reference drhodt has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(261,11) ]
      remark #15388: vectorization support: reference drhods has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference sq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference sqr has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15388: vectorization support: reference tq has aligned access   [ state_test_offload.F90(272,10) ]
      remark #15301: SIMD LOOP WAS VECTORIZED
      remark #15475: --- begin vector loop cost summary ---
      remark #15476: scalar loop cost: 322 
      remark #15477: vector loop cost: 43.000 
      remark #15478: estimated potential speedup: 7.480 
      remark #15479: lightweight vector operations: 176 
      remark #15488: --- end vector loop cost summary ---
      remark #25018: Total number of lines prefetched=12
      remark #25019: Number of spatial prefetches=12, dist=8
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(231,30) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(232,41) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(238,12) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(247,11) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(261,11) ]
      remark #25139: Using second-level distance 2 for prefetching spatial memory reference   [ state_test_offload.F90(272,10) ]
      remark #25015: Estimate of max trip count of loop=1000
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

state_test_offload.F90(152,1):remark #34026: call to memcpy implemented as a call to optimized library version
state_test_offload.F90(152,1):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (64, 0), and destination (alignment, offset): (64, 0)
===========================================================================

    Report from: Interprocedural optimizations [ipo]

INLINING FOOTNOTES:

<1> Inlining the subprogram will lead to incorrect program behavior.

